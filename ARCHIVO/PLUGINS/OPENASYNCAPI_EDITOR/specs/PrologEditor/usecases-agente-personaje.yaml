# Use Cases: Agente Personaje (Teatro ARG-Board)
# Caso de Uso: InteracciÃ³n MCP/REST con el Server durante EjecuciÃ³n de Obra
# 
# Actores: Agente Personaje (IA), MCPPrologServer, PrologEditor Backend
# Epic: TEATRO-PROLOG-1.0.0
# Version: 1.0.0
# Schema: usecases/1.0.0 (Aleph Scriptorium)

spec: usecases
version: 1.0.0

info:
  title: Use Cases - Agente Personaje Teatro
  description: |
    EspecificaciÃ³n de casos de uso para agentes personaje del plugin Teatro
    que interactÃºan con el MCPPrologServer durante la ejecuciÃ³n de obras.
    
    ## Concepto: Agente Personaje
    
    Un **agente personaje** es una entidad IA que:
    - Tiene un cerebro Prolog (.brain.pl) que define su comportamiento
    - Participa en escenas de una obra de teatro interactivo
    - Toma decisiones autÃ³nomas basadas en contexto
    - InteractÃºa con otros personajes y con el pÃºblico
    
    ## Arquitectura de ComunicaciÃ³n
    
    ```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    RUNTIME DE OBRA                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                                  â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
    â”‚  â”‚   Teatro    â”‚     â”‚ Agente      â”‚     â”‚ Agente      â”‚        â”‚
    â”‚  â”‚ Orquestador â”‚     â”‚ Personaje A â”‚     â”‚ Personaje B â”‚        â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
    â”‚         â”‚                   â”‚                   â”‚                â”‚
    â”‚         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
    â”‚         â”‚    â”‚                                                   â”‚
    â”‚         â–¼    â–¼                                                   â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
    â”‚  â”‚  MCP Protocol   â”‚ â† Tools + Resources + Prompts               â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
    â”‚           â”‚                                                      â”‚
    â”‚           â–¼                                                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
    â”‚  â”‚ MCPPrologServer â”‚â”€â”€â”€â”€â–ºâ”‚ SWI-Prolog      â”‚                     â”‚
    â”‚  â”‚   (port 3006)   â”‚     â”‚ (swipl-stdio)   â”‚                     â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
    â”‚           â”‚                                                      â”‚
    â”‚           â–¼ HTTP (sin ciclos MCP)                                â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
    â”‚  â”‚ Backend SQLite  â”‚ â† Persistencia de estado                    â”‚
    â”‚  â”‚   (port 8000)   â”‚                                             â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    ```
    
    ## Modos de InteracciÃ³n
    
    | Modo | Protocolo | CuÃ¡ndo usar |
    |------|-----------|-------------|
    | **MCP** | JSON-RPC via stdio | Copilot Chat, agentes IA |
    | **REST** | HTTP | Frontend Angular, integraciones externas |
    | **HÃ­brido** | MCP + REST | MCPPrologServer accede a SQLite |
    
  version: 1.0.0
  contact:
    name: Aleph Scriptorium
  license:
    name: AIPL v1.0

servers:
  mcpServer:
    host: localhost:3006
    protocol: mcp
    description: MCPPrologServer - Motor de razonamiento
  
  restBackend:
    host: localhost:8000
    protocol: http
    description: PrologEditor Backend - Persistencia

# ============================================================================
# USE CASES
# ============================================================================

x-use-cases:
  
  # --------------------------------------------------------------------------
  # UC-AGENT-001: Iniciar SesiÃ³n de Personaje
  # --------------------------------------------------------------------------
  UC-AGENT-001:
    name: Iniciar SesiÃ³n de Personaje
    actor: "Agente Personaje"
    protocol: MCP
    preconditions:
      - MCPPrologServer activo (puerto 3006)
      - Brain del personaje disponible (.brain.pl)
      - Obra registrada en obras.yaml
    trigger: "Orquestador Teatro inicia escena con personaje"
    flow:
      - step: 1
        action: "Crear sesiÃ³n vinculada a obra"
        mcp_call:
          method: tools/call
          tool: prolog_create_session
          arguments:
            sessionId: "{obra}_{personaje}_{timestamp}"
            obraId: "{obra}"
        response:
          success: true
          sessionId: "itaca_lucas_1704283200"
      
      - step: 2
        action: "Cargar cerebro del personaje"
        mcp_call:
          method: tools/call
          tool: prolog_consult_file
          arguments:
            sessionId: "{sessionId}"
            filePath: "ARCHIVO/PLUGINS/AGENT_CREATOR/templates/{personaje}.brain.pl"
        response:
          success: true
          message: "brain_{personaje} loaded"
      
      - step: 3
        action: "Cargar contexto de escena"
        mcp_call:
          method: tools/call
          tool: prolog_assert_fact
          arguments:
            sessionId: "{sessionId}"
            fact: "contexto(inicio)."
        response:
          success: true
      
      - step: 4
        action: "Cargar estado de obra desde DB (opcional)"
        mcp_call:
          method: tools/call
          tool: prolog_load_rules_from_db
          arguments:
            sessionId: "{sessionId}"
            appFilter: "{obra}"
        response:
          success: true
          rulesLoaded: 5
    
    postconditions:
      - SesiÃ³n activa con ID Ãºnico
      - Brain cargado en Knowledge Base
      - Contexto inicial establecido
      - Estado persistido restaurado
    
    sequence_diagram: |
      Orquestador     MCPPrologServer     SWI-Prolog     Backend
          â”‚                 â”‚                 â”‚             â”‚
          â”‚â”€â”€create_sessionâ”€â–º                 â”‚             â”‚
          â”‚                 â”‚â”€â”€spawn processâ”€â–ºâ”‚             â”‚
          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â—„â”€â”€â”€readyâ”€â”€â”€â”€â”€â”€â”€â”€â”‚             â”‚
          â”‚                 â”‚                 â”‚             â”‚
          â”‚â”€â”€consult_fileâ”€â”€â”€â–º                 â”‚             â”‚
          â”‚                 â”‚â”€â”€consult/1â”€â”€â”€â”€â”€â–ºâ”‚             â”‚
          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â—„â”€â”€â”€loadedâ”€â”€â”€â”€â”€â”€â”€â”‚             â”‚
          â”‚                 â”‚                 â”‚             â”‚
          â”‚â”€â”€load_rules_from_dbâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
          â”‚                 â”‚                 â”‚â—„â”€â”€HTTP GETâ”€â”€â”‚
          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â—„â”€â”€â”€â”€rulesâ”€â”€â”€â”€â”€â”€â”€â”‚             â”‚

  # --------------------------------------------------------------------------
  # UC-AGENT-002: Tomar DecisiÃ³n en Escena
  # --------------------------------------------------------------------------
  UC-AGENT-002:
    name: Tomar DecisiÃ³n en Escena
    actor: "Agente Personaje"
    protocol: MCP
    preconditions:
      - SesiÃ³n activa (UC-AGENT-001)
      - Contexto actual definido
    trigger: "Orquestador solicita acciÃ³n del personaje"
    flow:
      - step: 1
        action: "Consultar estado actual (resource)"
        mcp_call:
          method: resources/read
          uri: "prolog://sessions/current"
        response:
          sessionId: "{sessionId}"
          contexto: "crisis"
          factsCount: 15
          rulesCount: 8
      
      - step: 2
        action: "Ejecutar decidir_accion/2"
        mcp_call:
          method: tools/call
          tool: prolog_query
          arguments:
            sessionId: "{sessionId}"
            query: "decidir_accion({personaje}, Accion)."
        response:
          success: true
          results:
            - Accion: "verificar_indices"
          bindings:
            - {"Accion": "verificar_indices"}
      
      - step: 3
        action: "Registrar decisiÃ³n tomada"
        mcp_call:
          method: tools/call
          tool: prolog_assert_fact
          arguments:
            sessionId: "{sessionId}"
            fact: "decision_tomada({personaje}, verificar_indices, {timestamp})."
      
      - step: 4
        action: "Retornar acciÃ³n al orquestador"
        output:
          personaje: "{personaje}"
          accion: "verificar_indices"
          confianza: 1.0
          razonamiento: "Regla regla_{personaje}(crisis, verificar_indices) activada"
    
    postconditions:
      - AcciÃ³n decidida
      - DecisiÃ³n registrada en KB
      - Orquestador informado
    
    notes: |
      El agente personaje NO ejecuta la acciÃ³n directamente.
      Retorna la acciÃ³n al orquestador que decide cÃ³mo manifestarla
      (texto, voz, animaciÃ³n, etc.)

  # --------------------------------------------------------------------------
  # UC-AGENT-003: Reaccionar a Evento Externo
  # --------------------------------------------------------------------------
  UC-AGENT-003:
    name: Reaccionar a Evento Externo
    actor: "Agente Personaje"
    protocol: "MCP + AsyncAPI"
    preconditions:
      - SesiÃ³n activa
      - SuscripciÃ³n a eventos activa
    trigger: "Evento externo (pÃºblico, sensor, otro personaje)"
    flow:
      - step: 1
        action: "Recibir evento (via orquestador o MQTT)"
        event:
          type: "accion_personaje"
          source: "lucas"
          action: "verificar_indices"
          target: "mentor"
      
      - step: 2
        action: "Actualizar contexto con evento"
        mcp_call:
          method: tools/call
          tool: prolog_assert_fact
          arguments:
            sessionId: "{sessionId}"
            fact: "evento(accion_personaje, lucas, verificar_indices)."
      
      - step: 3
        action: "Re-evaluar decisiÃ³n"
        description: "El contexto cambiÃ³, volver a consultar"
        mcp_call:
          method: tools/call
          tool: prolog_query
          arguments:
            sessionId: "{sessionId}"
            query: "decidir_accion({personaje}, Accion)."
        response:
          results:
            - Accion: "ofrecer_ayuda"
      
      - step: 4
        action: "Emitir reacciÃ³n"
        output:
          personaje: "{personaje}"
          accion: "ofrecer_ayuda"
          trigger: "evento(accion_personaje, lucas, verificar_indices)"
    
    postconditions:
      - Evento procesado
      - Contexto actualizado
      - Nueva acciÃ³n disponible

  # --------------------------------------------------------------------------
  # UC-AGENT-004: Interactuar con Otro Personaje
  # --------------------------------------------------------------------------
  UC-AGENT-004:
    name: Interactuar con Otro Personaje
    actor: "Agente Personaje A"
    coactor: "Agente Personaje B"
    protocol: MCP
    preconditions:
      - Ambos personajes con sesiones activas
      - Ambos en la misma escena
    trigger: "Personaje A decide comunicarse con B"
    flow:
      - step: 1
        action: "A decide comunicar"
        mcp_query: "decidir_accion(lucas, comunicar(mentor, consulta))."
        result: "comunicar(mentor, consulta)"
      
      - step: 2
        action: "Orquestador notifica a B"
        event:
          type: "comunicacion"
          from: "lucas"
          to: "mentor"
          mensaje: "consulta"
      
      - step: 3
        action: "B actualiza su contexto"
        mcp_call:
          tool: prolog_assert_fact
          arguments:
            sessionId: "{session_mentor}"
            fact: "comunicacion_recibida(lucas, consulta)."
      
      - step: 4
        action: "B decide respuesta"
        mcp_query: "decidir_accion(mentor, Respuesta)."
        result: "responder(lucas, orientacion)"
      
      - step: 5
        action: "Orquestador notifica a A"
        event:
          type: "respuesta"
          from: "mentor"
          to: "lucas"
          contenido: "orientacion"
      
      - step: 6
        action: "A procesa respuesta"
        mcp_call:
          tool: prolog_assert_fact
          arguments:
            sessionId: "{session_lucas}"
            fact: "respuesta_recibida(mentor, orientacion)."
    
    postconditions:
      - ComunicaciÃ³n bidireccional completada
      - Ambos contextos actualizados
      - InteracciÃ³n registrada en ambas KBs
    
    sequence_diagram: |
      Lucas           Orquestador         Mentor
        â”‚                  â”‚                 â”‚
        â”‚â”€â”€comunicar(mentor)â”€â–º              â”‚
        â”‚                  â”‚â”€â”€notifyâ”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
        â”‚                  â”‚                 â”‚â”€â”€assert(comunicacion)
        â”‚                  â”‚                 â”‚â”€â”€query(decidir_accion)
        â”‚                  â”‚â—„â”€â”€responderâ”€â”€â”€â”€â”€â”‚
        â”‚â—„â”€â”€â”€respuestaâ”€â”€â”€â”€â”€â”‚                 â”‚
        â”‚â”€â”€assert(respuesta)                 â”‚

  # --------------------------------------------------------------------------
  # UC-AGENT-005: Persistir Estado para Continuidad
  # --------------------------------------------------------------------------
  UC-AGENT-005:
    name: Persistir Estado para Continuidad
    actor: "Agente Personaje"
    protocol: "MCP â†’ REST"
    preconditions:
      - SesiÃ³n activa con estado significativo
      - Backend disponible
    trigger: |
      - Fin de escena
      - Cambio importante de estado
      - Timeout de inactividad
    flow:
      - step: 1
        action: "Extraer hechos dinÃ¡micos"
        mcp_call:
          tool: prolog_query
          arguments:
            sessionId: "{sessionId}"
            query: "findall(F, dynamic_fact(F), Facts)."
        response:
          Facts: ["contexto(resolucion)", "decision_tomada(lucas, x, t)"]
      
      - step: 2
        action: "Serializar estado"
        process: "Convertir hechos a reglas Prolog persistibles"
        output: |
          % Estado guardado: {timestamp}
          estado_guardado({personaje}, resolucion).
          historial_decision({personaje}, verificar_indices, {t1}).
          historial_decision({personaje}, escalar_a_ox, {t2}).
      
      - step: 3
        action: "Guardar en SQLite via MCP"
        mcp_call:
          tool: prolog_save_rule_to_db
          arguments:
            name: "estado_{personaje}_{timestamp}"
            content: "{estado_serializado}"
            app: "{obra}"
        response:
          success: true
          id: 42
      
      - step: 4
        action: "Actualizar resource de sesiÃ³n"
        note: "El resource prolog-session-state ahora refleja el guardado"
    
    postconditions:
      - Estado persistido en SQLite
      - Recuperable en sesiÃ³n futura
      - Auditable (quiÃ©n, cuÃ¡ndo, quÃ©)

  # --------------------------------------------------------------------------
  # UC-AGENT-006: Cerrar SesiÃ³n de Personaje
  # --------------------------------------------------------------------------
  UC-AGENT-006:
    name: Cerrar SesiÃ³n de Personaje
    actor: "Agente Personaje"
    protocol: MCP
    preconditions:
      - SesiÃ³n activa
      - Estado persistido (UC-AGENT-005) si es importante
    trigger: "Fin de obra o salida de personaje"
    flow:
      - step: 1
        action: "Verificar que no hay work pending"
        mcp_call:
          tool: prolog_query
          arguments:
            sessionId: "{sessionId}"
            query: "pending_work(X)."
        response:
          results: []
      
      - step: 2
        action: "Log de cierre"
        mcp_call:
          tool: prolog_assert_fact
          arguments:
            sessionId: "{sessionId}"
            fact: "sesion_cerrada({timestamp})."
      
      - step: 3
        action: "Destruir sesiÃ³n"
        mcp_call:
          tool: prolog_destroy_session
          arguments:
            sessionId: "{sessionId}"
        response:
          success: true
          message: "Session destroyed"
      
      - step: 4
        action: "Confirmar liberaciÃ³n de recursos"
        mcp_call:
          tool: prolog_list_sessions
        response:
          sessions: []  # o sin la sesiÃ³n destruida
    
    postconditions:
      - SesiÃ³n eliminada
      - Proceso SWI-Prolog terminado
      - Memoria liberada

# ============================================================================
# PROMPT ORQUESTADOR: teatro_agent_session
# ============================================================================

x-prompts:
  teatro_agent_session:
    name: "Workflow E2E para Agente Personaje"
    description: |
      Este prompt guÃ­a a un agente IA para orquestar una sesiÃ³n completa
      de un personaje de teatro, desde inicio hasta cierre.
    
    template: |
      ## ğŸ­ SesiÃ³n de Personaje: {{personaje}}
      
      **Obra**: {{obraId}}
      **Contexto inicial**: {{contexto | default: 'inicio'}}
      
      ### Paso 1: Iniciar sesiÃ³n
      Usa `prolog_create_session` con sessionId Ãºnico.
      
      ### Paso 2: Cargar cerebro
      Usa `prolog_consult_file` para cargar {{personaje}}.brain.pl
      
      ### Paso 3: Establecer contexto
      Usa `prolog_assert_fact` con contexto({{contexto}}).
      
      ### Paso 4: Consultar acciÃ³n
      Usa `prolog_query` con decidir_accion({{personaje}}, X).
      
      ### Paso 5: Procesar resultado
      - Si hay acciÃ³n: reportar al usuario
      - Si no hay match: contexto desconocido, escalar
      
      ### Paso 6 (opcional): Persistir
      Si la acciÃ³n es significativa, guardar con `prolog_save_rule_to_db`.
      
      ### Paso 7: Cerrar o continuar
      - Continuar: volver al paso 3 con nuevo contexto
      - Cerrar: `prolog_destroy_session`
    
    arguments:
      - name: personaje
        required: true
        description: "Nombre del personaje (lowercase)"
      - name: obraId
        required: true
        description: "ID de la obra activa"
      - name: contexto
        required: false
        description: "Contexto inicial (default: inicio)"

# ============================================================================
# CONTRATOS DE DATOS
# ============================================================================

components:
  schemas:
    
    DecisionResult:
      type: object
      description: "Resultado de una decisiÃ³n de personaje"
      properties:
        personaje:
          type: string
          example: "lucas"
        accion:
          type: string
          example: "verificar_indices"
        confianza:
          type: number
          minimum: 0
          maximum: 1
          example: 1.0
        razonamiento:
          type: string
          example: "Regla activada por contexto 'crisis'"
        timestamp:
          type: string
          format: date-time
      required: [personaje, accion]
    
    EventoEscena:
      type: object
      description: "Evento que ocurre en una escena"
      properties:
        type:
          type: string
          enum: [accion_personaje, comunicacion, respuesta, sensor, publico]
        source:
          type: string
          description: "Origen del evento"
        target:
          type: string
          description: "Destino del evento (opcional)"
        payload:
          type: object
          description: "Datos del evento"
        timestamp:
          type: string
          format: date-time
      required: [type, source]
    
    EstadoPersonaje:
      type: object
      description: "Estado serializado de un personaje"
      properties:
        personaje:
          type: string
        obra:
          type: string
        contexto_actual:
          type: string
        decisiones_historial:
          type: array
          items:
            type: object
            properties:
              accion:
                type: string
              timestamp:
                type: string
        hechos_dinamicos:
          type: array
          items:
            type: string
        guardado_en:
          type: string
          format: date-time

# ============================================================================
# MÃ‰TRICAS DE PERFORMANCE
# ============================================================================

x-performance-metrics:
  
  latencia_decision:
    description: "Tiempo desde query hasta respuesta"
    target: "< 100ms"
    measurement: "Timestamp respuesta - timestamp request"
  
  throughput_escena:
    description: "Decisiones por minuto por personaje"
    target: "> 60 decisiones/min"
    notes: "Para obras en tiempo real"
  
  memoria_sesion:
    description: "Memoria consumida por sesiÃ³n Prolog"
    target: "< 50MB por personaje"
    measurement: "RSS del proceso swipl hijo"
  
  persistencia_latencia:
    description: "Tiempo de guardado a SQLite"
    target: "< 200ms"
    includes: "MCP call + HTTP + SQLite write"
